/**
* Program that estimates the value generated by
* the sine function for when it is given a random value between -2PI and 2PI
* using a multilayer perceptron.
* #NOTE: outputs may be undefined if the weights have exploded
**/

#include <iostream>
#define _USE_MATH_DEFINES
#include <cmath>
#include <ctime>
#include <random>
#include <fstream>
#include <Nemesis/Estimator/NeuralNetwork/MultiLayerPerceptron.hpp>
#include <Nemesis/Model/TDLearner.hpp>

#ifndef M_PI
#define M_PI 3.14159265358979323846f
#endif
using namespace std;
std::mt19937 randng(std::time(0));
std::uniform_real_distribution<float> dist(-2*M_PI, 2*M_PI);

typedef MultiLayerPerceptron<> MLP; // definition exists to avoid having to add template braces at all

int main() {
	auto func = [](float x) { return sin(x); };
	TDLearner<MLP> agent(MLP(1, 1));
	std::ifstream neural_net_file("test_net.json");
	if (!neural_net_file.good()) {
		agent.q_estimator->append_layer(Layer<>(6, TanhActivation<>()));
		agent.q_estimator->append_layer(Layer<>(8, TanhActivation<>()));
		agent.q_estimator->append_layer(Layer<>(8, TanhActivation<>()));
		agent.q_estimator->append_layer(Layer<>(1, LinearActivation<>()));
		agent.q_estimator->save("test_net_1.json");
		std::printf("initialized:\n");
	}

	agent.q_estimator->load("test_net_1.json");
	std::cout << agent.q_estimator->as_json() << std::endl;
	agent.q_estimator->set_epoch(0);
	agent.q_estimator->set_learning_rate(.1f);
	auto training_iter = 1000000;
	agent.q_estimator->set_learning_decay(1.f / training_iter);
	auto training_div = 10000;

	auto num_in_div = training_iter / training_div;

	std::vector<std::vector<TrainingInstance<>>> instances(training_div, std::vector<TrainingInstance<>>(num_in_div));
	for (int i = 0; i < training_div; ++i) {
		for (int j = 0; j < num_in_div; ++j) {
			float rand_value = dist(randng);
			float actual_ans = func(rand_value);
			// TDLearner doesn't support batch learning, is meant to be used with online learning
			//auto a = std::vector<float>({ rand_value });
			//auto b = std::vector<float>({ actual_ans });
			instances[i][j] = TrainingInstance<>({ rand_value }, { actual_ans });
			//agent.update_values(a, b, { 0 });
			//if (j % training_div == 0) {
			//	std::printf("training %.2f complete\n", j * 100 / ((float)training_iter));
			//}
		}
	}
	for (int i = 0; i < training_div; ++i) {
		agent.q_estimator->fit({instances[i][0]});
	}
	const int num_questions = 16;
	std::vector<float> test_answers(num_questions);
	std::vector<float> test_responses(num_questions);
	for (int i = 0; i < num_questions; ++i) {
		float rand_value = dist(randng);
		float actual_ans = func(rand_value);
		auto response = agent.get_value({ rand_value })[0];
		std::printf("-----------------\nquestion: sin(%f) = ?,\n actual ans: %f response: %f\n",
					rand_value, actual_ans, response);
	}

	agent.q_estimator->save("test_net_1.json");
	std::cin.get();
	return 0;
}